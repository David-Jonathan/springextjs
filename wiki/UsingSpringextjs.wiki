How to use springextjs

= Introduction =

The goal of this project is to easily integrate Spring3 with ExtJS remoting specification.
I have tried to make it as simple as possible but I am sure there is much room for improvement.

Polling remoting has not been completely worked out but will be in coming weeks.


= Setting Up Controller=

This is as simple as extending a the base abstract controller

{{{
@Controller
@RequestMapping(value = "/extjs/remoting")
public class MyRemotingController extends ExtJsRemotingController{
...
}
}}}

All methods in the controller which are non form submission should be annotated

{{{
@ExtJsRemotingMethod (paramLength = 1)
public User getUser(long userId) throws Exception{
    return userService.getUser(userId);        
}
}}}

Following the flexibility of Spring3, the input parameters can be any primitive or wrapper type, String, net.sf.json.JSONArray or net.sf.json.JSONObject, ServletRequest, ServletResponse, or Locale.

=Form Handling in ExtJS Remoting Controllers=

All methods which are form handlers should be annotated using Springs standard annotation of:

{{{
@RequestMapping (value="/updateUser", method = RequestMethod.POST)
}}}

And return ModelAndView. They can also use any standard Spring annotations as needed:

{{{
@ExtJsRemotingMethod(paramLength = 1)
@RequestMapping (value="/updateUser", method = RequestMethod.POST)
public ModelAndView updateUser (Locale locale, HttpServletRequest request, @Valid User user,BindingResult result){
.....
}
}}}

The parameters are limited to what Spring is limited to.

=Form Handler Method Results=

The results of form handler methods should be returned using the protected method "responseModelAndView". This method returns a special ExtJsRemotingJacksonJsonView object which is an extension of the MappingJacksonJsonView object. If this method is not used to return the object, the developer is free to write their own mechanism so long as it conforms to the ExtJS remoting spec. The MessageSource object passed in the "responseModelAndView" method contains messages for field validation in case of validation failure. Besides request and isSuccess parameters, everything else passed in the "responseModelAndView" method can be null.

{{{
ExtJsRemotingMethod(paramLength = 1)
    @RequestMapping (value="/createUser", method = RequestMethod.POST)
    public ModelAndView createUser (Locale locale, HttpServletRequest request, @Valid UserForm userForm, BindingResult result){
        boolean isSuccess = false;
        String message = null;
        log.info("Attempting creating user: " + userForm.getUsername());
        if (!result.hasErrors()){

            try{
                UserBean userBean = new UserBean ();
                PropertyUtils.copyProperties(userBean, userForm);
                this.userService.createUser(userBean, userForm.isNotifyUser());
                isSuccess= true;
                message = this.messageSource.getMessage("user.create.success.message", null, locale);
                log.info("User created successfully with username: " + userForm.getUsername());
            }
            catch (UserNameNotAvailableException e){
                log.error("Unable to create user, user name is taken: " +  userForm.getUsername());
                result.rejectValue("username", "username.in.use.message", null, "Username is in use");
            }
            catch (Exception e){
                log.error ("Error: " + e, e);
                message = this.messageSource.getMessage("user.create.fail.message", null, locale);
            }

        }
        return this.remotingFormPostModelAndView(request, isSuccess, locale, this.messageSource, message, result);
    }

}}}


=Handling ExtJS Remoting Form Load API Calls=

Form loads are to be implemented in non form submission controller methods with domain objects wrapped with the ExtJsFormResultWrapperBean class.  The protected method named "getFormLoadObject" in the ExtJsRemotingController can be used to wrap the object needed to load ExtJS form like:

{{{
@ExtJsRemotingMethod (paramLength = 1)
public ExtJsFormResultWrapperBean loadUser (long userId) throws Exception{
    return this.getFormLoadObject(this.userService.loadUser(userId));
}
}}}

= Setting Up Client JavaScript=

Use the utility method to output the remoting API JSON in the browser:

{{{
<script type="text/javascript"> 
                <%= com.google.code.springextjs.remoting.util.ExtJsRemotingUtil.createExtRemotingApiString(
                        request.getContextPath() + "/extjs/remoting/router",
                        my.spring.mvc.controller.MyExtJsRemotingController.class,
                        "MyRemotingApi")%>

....
                         
</script>
}}}


This will auto generate the remoting code off your controller like:

{{{
MyRemotingApi = {....}
}}}

And use it as stated in the ExtJS documentation like:

{{{
var remotingProvider = new Ext.direct.RemotingProvider (MyRemotingApi);
Ext.Direct.addProvider(remotingProvider);
}}}

You can just as easily call the utility on the server and pass the generated ExtJS remoting API to the browser using an init Ajax call then load the API in ExtJS as stated above.

=Router End Point=

By default the router RequestMapping is /router. So if you implemented a router controller with the following Spring annotation:

{{{
@RequestMapping(value = "/extjs/remoting")
}}}

Then the URL will be /extjs/remoting/router. To change the default "/router" mapping, simply re-implement the "router" method in the base controller and update the mapping as desired.